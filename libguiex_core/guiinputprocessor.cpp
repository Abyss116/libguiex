/** 
* @file guiinputprocessor.cpp
* @brief widget input processor
* @author ken
* @date 2007-05-24
*/


//============================================================================//
// include
//============================================================================// 
#include <libguiex_core/guiinputprocessor.h>
#include <libguiex_core/guiwidgetsystem.h>
#include <libguiex_core/guiwidget.h>
#include <libguiex_core/guiwidgetfactory.h>

#include <libguiex_core/guimousecursor.h>


#include <libguiex_core/guievent.h>

#include <libguiex_core/guiexception.h>

#include <libguiex_core/guiinterfacemanager.h>
#include <libguiex_core/guiinterfacemouse.h>
#include <libguiex_core/guiinterfacekeyboard.h>

//------------------------------------------------------------------------------

//------------------------------------------------------------------------------ 


//============================================================================//
// internal use class
//============================================================================// 

namespace guiex
{
	/**
	* @brief used to track mouse operation
	*/
	class CMouseTracker
	{
	public:
		/// constructor
		CMouseTracker()
		{
			Reset();
		}

		/// reset the tracker
		void Reset()
		{
			for( int i = 0; i< _MOUSE_BUTTON_MAX_; ++i )
			{
				m_aButtonTrack[i].m_nClickCount = 1;
				m_aButtonTrack[i].m_pTargetWidget = NULL;
				m_aButtonTrack[i].m_uLastDownEvent = eEVENT_MOUSE_DOWN;
			}
			m_pWidgetUnderMouse = NULL;
		}

	public:
		struct 
		{
			real			m_fTimer;			//!< Timer used to track clicks for this button.
			uint32			m_nClickCount;		//!< count of clicks made so far.
			CGUIWidget*		m_pTargetWidget;    //!< target window for any events generated.
			uint32			m_uLastDownEvent;	//!< last event generated by mouse down
		}
		m_aButtonTrack[_MOUSE_BUTTON_MAX_];

		CGUIWidget*			m_pWidgetUnderMouse;	//!< the widget that under mouse
	};



	/**
	* @brief used for drag
	*/
	class CDragTracker
	{
	public:
		/// constructor
		CDragTracker()
		{
			Reset();
		}

		/// reset the tracker
		void Reset()
		{
			m_pDragItem = NULL;
		}

	public:
		CGUIWidget*		m_pDragItem;	///!< the widget which is being dragged now.
		CGUIVector2		m_aDeltaPos;	///!< this value is used to calculate the widget's position.
		int32			m_nButton;		///!< button of mouse which used to drag widget
	};
}


//============================================================================//
// function
//============================================================================// 
namespace guiex
{
	//------------------------------------------------------------------------------
	CGUIInputProcessor::CGUIInputProcessor()
		:m_pMouseTracker(new CMouseTracker)
		,m_pDragTracker(new CDragTracker)
		,m_fDbClickTimeout(GUI_DBCLICK_TIME)
		,m_pSystem(NULL)
	{
		GUI_ASSERT(m_pMouseTracker,"error");
		GUI_ASSERT(m_pDragTracker,"error");
	}
	//------------------------------------------------------------------------------
	CGUIInputProcessor::~CGUIInputProcessor()
	{
		delete m_pMouseTracker;
		delete m_pDragTracker;
	}
	//------------------------------------------------------------------------------
	void	CGUIInputProcessor::SetSystem(CGUISystem* pSystem)
	{
		m_pSystem = pSystem;
	}
	//------------------------------------------------------------------------------
	void	CGUIInputProcessor::Reset()
	{
		m_pMouseTracker->Reset();	
		m_pDragTracker->Reset();
	}
	//------------------------------------------------------------------------------
	bool	CGUIInputProcessor::ProcessKeyboard(const IGUIInterfaceKeyboard::SKeyEvent& rKeyEvent)
	{
		IGUIInterfaceKeyboard* pKeyboard = CGUIInterfaceManager::Instance()->GetInterfaceKeyboard();
		pKeyboard->PreUpdate();

		//get key status
		CGUIWidget *pFocusWidget = m_pSystem->GetFocusWidget();

		uint32	nEventId = 0;
		switch(rKeyEvent.m_eKeyEvent)
		{
		case KEY_EVENT_DOWN:
			nEventId = eEVENT_KEY_DOWN;
			break;
		case KEY_EVENT_UP:
			nEventId = eEVENT_KEY_UP;
			break;
		case KEY_EVENT_PRESSED:
			nEventId = eEVENT_KEY_PRESSED;
			break;
		case KEY_EVENT_CLICKED:
			nEventId = eEVENT_KEY_CLICKED;
			break;
		default:
			GUI_FORCE_ASSERT("unknown keyboard id");
			break;
		}

		//event
		CGUIEventKeyboard aEvent;
		aEvent.SetEventId(nEventId);	
		aEvent.SetKeyCode( rKeyEvent.m_eKeyCode);
		aEvent.SetKeyboardInterface(pKeyboard);
		if( pFocusWidget )
		{
			//focus widget process this event at first
			aEvent.SetReceiver(pFocusWidget);
			GSystem->SendEvent(&aEvent);
		}

		if( !aEvent.IsConsumed())
		{
			//the focus widget doesn't process this event, check global
			//key register now
			m_pSystem->ProcessGlobalKeyEvent(&aEvent);
		}

		//update keyboard status
		pKeyboard->PostUpdate();

		return aEvent.IsConsumed();
	}

	//------------------------------------------------------------------------------
	bool	CGUIInputProcessor::ProcessMouse(const IGUIInterfaceMouse::SMouseEvent& rMouseEvent)
	{
		IGUIInterfaceMouse* pMouse = CGUIInterfaceManager::Instance()->GetInterfaceMouse();
		pMouse->PreUpdate();

		bool bConsumed = false;

		switch(rMouseEvent.m_eMouseEvent)
		{
		case MOUSE_EVENT_MOVE:
			bConsumed = OnMouseMove(rMouseEvent);
			break;
		case MOUSE_EVENT_DOWN:
			bConsumed = OnMouseButtonDown(rMouseEvent);
			break;
		case MOUSE_EVENT_UP:
			bConsumed = OnMouseButtonUp(rMouseEvent);
			break;
		case MOUSE_EVENT_WHEEL:
			bConsumed = OnMouseWheelChange(rMouseEvent);
			break;
		default:
			GUI_FORCE_ASSERT("unknown mouse event");
			break;
		}

		//update mouse status
		pMouse->PostUpdate();

		return bConsumed;
	}
	//------------------------------------------------------------------------------
	bool CGUIInputProcessor::OnMouseButtonDown(const IGUIInterfaceMouse::SMouseEvent& rMouseEvent)
	{
		bool bConsumed = false;

		CGUIWidget* pTargetWidget = m_pSystem->GetWidgetUnderPoint(rMouseEvent.m_aMousePos);

		if( !m_pMouseTracker->m_aButtonTrack[rMouseEvent.m_eButton].m_pTargetWidget ||
			pTargetWidget != m_pMouseTracker->m_aButtonTrack[rMouseEvent.m_eButton].m_pTargetWidget ||
			m_pSystem->GetSystemTime() - m_pMouseTracker->m_aButtonTrack[rMouseEvent.m_eButton].m_fTimer > static_cast<int32>(m_fDbClickTimeout))
		{
			//reset mouse tracker
			m_pMouseTracker->m_aButtonTrack[rMouseEvent.m_eButton].m_pTargetWidget = pTargetWidget;
			m_pMouseTracker->m_aButtonTrack[rMouseEvent.m_eButton].m_nClickCount = 1;
		}
		else
		{
			//add click count
			++m_pMouseTracker->m_aButtonTrack[rMouseEvent.m_eButton].m_nClickCount;
		}
		//re-initialize timer
		m_pMouseTracker->m_aButtonTrack[rMouseEvent.m_eButton].m_fTimer = m_pSystem->GetSystemTime();

		if( pTargetWidget )
		{
			//set focus
			if( m_pSystem->GetFocusWidget() != pTargetWidget)
			{
				// if( pTargetWidget->IsFocusable())
				{
					pTargetWidget->SetFocus(true);
				}
			}

			//set active
			if( pTargetWidget->IsDerivedActivable())
			{
				CGUIEventNotification aEvent;
				aEvent.SetEventId(eEVENT_ACTIVE);
				aEvent.SetReceiver(pTargetWidget);
				GSystem->SendEvent(&aEvent);
			}

			//mouse down, mouse double click and multi click event
			CGUIEventMouse aEventMouse;
			aEventMouse.SetButton( rMouseEvent.m_eButton );
			aEventMouse.SetReceiver( pTargetWidget );
			aEventMouse.SetPosition(rMouseEvent.m_aMousePos);
			aEventMouse.SetKeyboardInterface(CGUIInterfaceManager::Instance()->GetInterfaceKeyboard());


			switch( m_pMouseTracker->m_aButtonTrack[rMouseEvent.m_eButton].m_nClickCount )
			{
			case 1:
				aEventMouse.SetEventId(eEVENT_MOUSE_DOWN);
				break;

			case 2:
				if( pTargetWidget->IsGenerateDBClickEvent())
				{
					aEventMouse.SetEventId(eEVENT_MOUSE_DBCLICK);
				}
				else
				{
					aEventMouse.SetEventId(eEVENT_MOUSE_DOWN);
				}
				break;

			default:
				if( pTargetWidget->IsGenerateMultiClickEvent())
				{
					aEventMouse.SetEventId(eEVENT_MOUSE_MULTI_CLICK);
					aEventMouse.SetMultiClickCount(m_pMouseTracker->m_aButtonTrack[rMouseEvent.m_eButton].m_nClickCount);
				}
				else
				{
					aEventMouse.SetEventId(eEVENT_MOUSE_DOWN);
				}
				break;
			}

			//for drag event
			if( pTargetWidget->IsMovable() &&
				aEventMouse.GetEventId() == eEVENT_MOUSE_DOWN &&
				rMouseEvent.m_eButton == MOUSE_LEFT )
			{
				//send drag begin event
				CGUIEventDrag aEventDrag;
				aEventDrag.SetEventId(eEVENT_DRAG_BEGIN );
				aEventDrag.SetReceiver( pTargetWidget );
				aEventDrag.SetButton( rMouseEvent.m_eButton );
				aEventDrag.SetWidgetPos(pTargetWidget->GetPixelPosition());
				aEventDrag.SetMousePos(rMouseEvent.m_aMousePos);
				GSystem->SendEvent(&aEventDrag);
				bConsumed |= aEventDrag.IsConsumed();
				
				if( !aEventDrag.IsExpired())
				{
					//set drag tracker
					BeginDrag( pTargetWidget, pTargetWidget->GetPixelPosition()-rMouseEvent.m_aMousePos, rMouseEvent.m_eButton);
				}
			}
			m_pMouseTracker->m_aButtonTrack[rMouseEvent.m_eButton].m_uLastDownEvent = aEventMouse.GetEventId();

			//mouse down event
			GSystem->SendEvent(&aEventMouse);
			bConsumed |= aEventMouse.IsConsumed();
		}
		else
		{
			if( m_pSystem->GetFocusWidget() )
			{
				m_pSystem->GetFocusWidget()->SetFocus(false);
			}
		}

		return bConsumed;
	}
	//------------------------------------------------------------------------------
	void	CGUIInputProcessor::BeginDrag(CGUIWidget* pWidget, const CGUIVector2& rDeltaPos, uint32 nButton)
	{
		m_pDragTracker->m_pDragItem = pWidget;
		m_pDragTracker->m_aDeltaPos = rDeltaPos;
		m_pDragTracker->m_nButton = nButton;
	}
	//------------------------------------------------------------------------------
	void	CGUIInputProcessor::EndDrag()
	{
		//clear drag tracker
		m_pDragTracker->m_pDragItem = NULL;
	}
	//------------------------------------------------------------------------------
	bool	CGUIInputProcessor::OnMouseButtonUp(const IGUIInterfaceMouse::SMouseEvent& rMouseEvent)
	{
		bool bConsumed = false;

		//for mouse up event
		CGUIWidget* pTargetWidget = m_pSystem->GetWidgetUnderPoint(rMouseEvent.m_aMousePos);

		if( pTargetWidget &&
			pTargetWidget == m_pMouseTracker->m_aButtonTrack[rMouseEvent.m_eButton].m_pTargetWidget )
		{
			if( m_pMouseTracker->m_aButtonTrack[rMouseEvent.m_eButton].m_uLastDownEvent == eEVENT_MOUSE_DOWN &&
				pTargetWidget->IsGenerateClickEvent())
			{
				//click event
				CGUIEventMouse aEventMouse;
				aEventMouse.SetEventId(eEVENT_MOUSE_CLICK);
				aEventMouse.SetButton( rMouseEvent.m_eButton );
				aEventMouse.SetPosition(rMouseEvent.m_aMousePos);
				aEventMouse.SetReceiver(pTargetWidget);
				aEventMouse.SetKeyboardInterface(CGUIInterfaceManager::Instance()->GetInterfaceKeyboard());
				GSystem->SendEvent(&aEventMouse);

				bConsumed |= aEventMouse.IsConsumed();
			}

			//mouse up event for this target
			CGUIEventMouse  aEventMouse;
			aEventMouse.SetEventId(eEVENT_MOUSE_UP);
			aEventMouse.SetButton( rMouseEvent.m_eButton );
			aEventMouse.SetReceiver(pTargetWidget);
			aEventMouse.SetPosition(rMouseEvent.m_aMousePos);
			aEventMouse.SetKeyboardInterface(CGUIInterfaceManager::Instance()->GetInterfaceKeyboard());
			GSystem->SendEvent(&aEventMouse);

			bConsumed |= aEventMouse.IsConsumed();
		}
		else
		{
			if( m_pMouseTracker->m_aButtonTrack[rMouseEvent.m_eButton].m_pTargetWidget )
			{
				//mouse up event for old target
				CGUIEventMouse aEventMouse;
				aEventMouse.SetEventId(eEVENT_MOUSE_UP);
				aEventMouse.SetButton( rMouseEvent.m_eButton );
				aEventMouse.SetReceiver(m_pMouseTracker->m_aButtonTrack[rMouseEvent.m_eButton].m_pTargetWidget);
				aEventMouse.SetPosition(rMouseEvent.m_aMousePos);
				aEventMouse.SetKeyboardInterface(CGUIInterfaceManager::Instance()->GetInterfaceKeyboard());
				GSystem->SendEvent(&aEventMouse);

				bConsumed |= aEventMouse.IsConsumed();
			}
			if( pTargetWidget )
			{
				//mouse up event for current target
				CGUIEventMouse aEventMouse;
				aEventMouse.SetEventId(eEVENT_MOUSE_UP);
				aEventMouse.SetButton( rMouseEvent.m_eButton );
				aEventMouse.SetReceiver(pTargetWidget);
				aEventMouse.SetPosition(rMouseEvent.m_aMousePos);
				aEventMouse.SetKeyboardInterface(CGUIInterfaceManager::Instance()->GetInterfaceKeyboard());
				GSystem->SendEvent(&aEventMouse);

				bConsumed |= aEventMouse.IsConsumed();
			}
		}

		// for drag event
		if(	rMouseEvent.m_eButton == m_pDragTracker->m_nButton  &&
			m_pDragTracker->m_pDragItem)
		{
			// send drag end event
			CGUIEventDrag aEventDrag;
			aEventDrag.SetEventId(eEVENT_DRAG_END );
			aEventDrag.SetReceiver( m_pDragTracker->m_pDragItem );
			aEventDrag.SetWidgetPos(m_pDragTracker->m_aDeltaPos + rMouseEvent.m_aMousePos);
			aEventDrag.SetMousePos(rMouseEvent.m_aMousePos);
			GSystem->SendEvent(&aEventDrag);
			bConsumed |= aEventDrag.IsConsumed();
			
			EndDrag();
		}

		return bConsumed;
	}
	//------------------------------------------------------------------------------
	bool	CGUIInputProcessor::OnMouseWheelChange(const IGUIInterfaceMouse::SMouseEvent& rMouseEvent)
	{
		bool bConsumed = false;

		CGUIWidget* pTargetWidget = m_pSystem->GetWidgetUnderPoint(rMouseEvent.m_aMousePos);

		if( pTargetWidget )
		{
			//mouse up event for current target
			CGUIEventMouse aEventMouse;
			aEventMouse.SetEventId(eEVENT_MOUSE_WHEEL);
			aEventMouse.SetReceiver(pTargetWidget);
			aEventMouse.SetPosition(rMouseEvent.m_aMousePos);
			aEventMouse.SetWheelChange(rMouseEvent.m_fWheelChange);
			aEventMouse.SetKeyboardInterface(CGUIInterfaceManager::Instance()->GetInterfaceKeyboard());
			GSystem->SendEvent(&aEventMouse);

			bConsumed |= aEventMouse.IsConsumed();
		}

		return bConsumed;
	}
	//------------------------------------------------------------------------------
	bool	CGUIInputProcessor::OnMouseMove(const IGUIInterfaceMouse::SMouseEvent& rMouseEvent)
	{
		bool bConsumed = false;

		//update mouse position
		CGUIMouseCursor::Instance()->SetPosition(rMouseEvent.m_aMousePos);

		// for drag event
		if(m_pDragTracker->m_pDragItem)
		{
			// send drag end event
			CGUIEventDrag aEventDrag;
			aEventDrag.SetEventId(eEVENT_DRAG_PROCESS );
			aEventDrag.SetReceiver( m_pDragTracker->m_pDragItem );
			aEventDrag.SetWidgetPos( m_pDragTracker->m_aDeltaPos + rMouseEvent.m_aMousePos);
			aEventDrag.SetMousePos(rMouseEvent.m_aMousePos);
			GSystem->SendEvent(&aEventDrag);

			bConsumed |= aEventDrag.IsConsumed();
		}
		else
		{
			CGUIWidget* pTargetWidget = m_pSystem->GetWidgetUnderPoint(rMouseEvent.m_aMousePos);


			//mouse leave and mouse enter event
			if( m_pMouseTracker->m_pWidgetUnderMouse != pTargetWidget )
			{
				//mouse leave
				if( m_pMouseTracker->m_pWidgetUnderMouse )
				{
					{
						//mouse move
						CGUIEventMouse aEventMouse;
						aEventMouse.SetEventId(eEVENT_MOUSE_MOVE);
						aEventMouse.SetReceiver(m_pMouseTracker->m_pWidgetUnderMouse);
						aEventMouse.SetPosition(rMouseEvent.m_aMousePos);
						aEventMouse.SetKeyboardInterface(CGUIInterfaceManager::Instance()->GetInterfaceKeyboard());
						GSystem->SendEvent(&aEventMouse);
					}

					{
						//mouse leave event for curent target
						CGUIEventMouse aEventMouse;
						aEventMouse.SetEventId(eEVENT_MOUSE_LEAVE);
						aEventMouse.SetReceiver(m_pMouseTracker->m_pWidgetUnderMouse);
						aEventMouse.SetPosition(rMouseEvent.m_aMousePos);
						aEventMouse.SetKeyboardInterface(CGUIInterfaceManager::Instance()->GetInterfaceKeyboard());
						GSystem->SendEvent(&aEventMouse);
					}
				}

				if( pTargetWidget )
				{
					//mouse enter event
					CGUIEventMouse aEventMouse;
					aEventMouse.SetEventId(eEVENT_MOUSE_ENTER);
					aEventMouse.SetReceiver(pTargetWidget);
					aEventMouse.SetPosition(rMouseEvent.m_aMousePos);
					aEventMouse.SetKeyboardInterface(CGUIInterfaceManager::Instance()->GetInterfaceKeyboard());
					GSystem->SendEvent(&aEventMouse);
				}

				m_pMouseTracker->m_pWidgetUnderMouse = pTargetWidget;
			}
			else if( m_pMouseTracker->m_pWidgetUnderMouse )
			{
				//mouse move event for curent target
				CGUIEventMouse aEventMouse;
				aEventMouse.SetEventId(eEVENT_MOUSE_MOVE);
				aEventMouse.SetReceiver(m_pMouseTracker->m_pWidgetUnderMouse);
				aEventMouse.SetPosition(rMouseEvent.m_aMousePos);
				aEventMouse.SetKeyboardInterface(CGUIInterfaceManager::Instance()->GetInterfaceKeyboard());
				GSystem->SendEvent(&aEventMouse);
			}
		}
		return bConsumed;
	}

}	//namespace
