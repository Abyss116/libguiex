/** 
* @file guiinputprocessor.cpp
* @brief widget input processor
* @author ken
* @date 2007-05-24
*/


//============================================================================//
// include
//============================================================================// 
#include "guiinputprocessor.h"
#include "guisystem.h"
#include "guiwidget.h"
#include "guiwidgetfactory.h"
#include "guimousecursor.h"
#include "guievent.h"
#include "guiexception.h"
#include "guiinterfacemanager.h"
#include "guiinterfacemouse.h"
#include "guiinterfacekeyboard.h"
#include "sigslot.h"


//============================================================================//
// internal use class
//============================================================================// 

namespace guiex
{
	/**
	* @brief used to track mouse operation
	*/
	class CMouseTracker : public sigslot::has_slots<>
	{
	public:
		/// constructor
		CMouseTracker()
			:m_pWidgetUnderMouse( NULL )
		{
			for( int i = 0; i< _MOUSE_BUTTON_MAX_; ++i )
			{
				m_aButtonTrack[i].m_nClickCount = 1;
				m_aButtonTrack[i].m_pTargetWidget = NULL;
				m_aButtonTrack[i].m_uLastDownEvent = eEVENT_MOUSE_DOWN;
			}
		}

		/// reset the tracker
		void Reset()
		{
			for( int i = 0; i< _MOUSE_BUTTON_MAX_; ++i )
			{
				m_aButtonTrack[i].m_nClickCount = 1;
				m_aButtonTrack[i].m_pTargetWidget = NULL;
				m_aButtonTrack[i].m_uLastDownEvent = eEVENT_MOUSE_DOWN;
			}
			SetWidgetUnderMouse( NULL );
		}

		void OnWidgetDestroyed( CGUIWidget* pWidget )
		{
			if( m_pWidgetUnderMouse == pWidget )
			{
				m_pWidgetUnderMouse = NULL;
			}
			for( uint32 i = 0; i< _MOUSE_BUTTON_MAX_; ++i )
			{
				if( m_aButtonTrack[i].m_pTargetWidget == pWidget )
				{
					SetTimer( i,0.0f );
					SetClickCount( i,1 );
					SetLastDownEvent( i,eEVENT_MOUSE_DOWN );
					SetTargetWidget( i,NULL );
				}
			}
		}

		void SetWidgetUnderMouse( CGUIWidget* pWidget )
		{
			if( m_pWidgetUnderMouse == pWidget )
			{
				return;
			}
			if( m_pWidgetUnderMouse )
			{
				m_pWidgetUnderMouse->GetOnWidgetDestroyedSignal().disconnect( this );
			}
			m_pWidgetUnderMouse = pWidget;
			if( m_pWidgetUnderMouse )
			{
				m_pWidgetUnderMouse->GetOnWidgetDestroyedSignal().connect( this, &CMouseTracker::OnWidgetDestroyed );
			}
		}

		CGUIWidget* GetWidgetUnderMouse()
		{
			return m_pWidgetUnderMouse;
		}

		real GetTimer( uint32 uButtonIdx )
		{
			GUI_ASSERT( uButtonIdx < _MOUSE_BUTTON_MAX_, "invalid button idx" );
			return m_aButtonTrack[uButtonIdx].m_fTimer;
		}

		void SetTimer( uint32 uButtonIdx, real fTimer )
		{
			GUI_ASSERT( uButtonIdx < _MOUSE_BUTTON_MAX_, "invalid button idx" );
			m_aButtonTrack[uButtonIdx].m_fTimer = fTimer;
		}

		uint32 GetClickCount( uint32 uButtonIdx )
		{
			GUI_ASSERT( uButtonIdx < _MOUSE_BUTTON_MAX_, "invalid button idx" );
			return m_aButtonTrack[uButtonIdx].m_nClickCount;
		}

		void SetClickCount( uint32 uButtonIdx, uint32 nClickCount )
		{
			GUI_ASSERT( uButtonIdx < _MOUSE_BUTTON_MAX_, "invalid button idx" );
			m_aButtonTrack[uButtonIdx].m_nClickCount = nClickCount;
		}

		uint32 GetLastDownEvent( uint32 uButtonIdx )
		{
			GUI_ASSERT( uButtonIdx < _MOUSE_BUTTON_MAX_, "invalid button idx" );
			return m_aButtonTrack[uButtonIdx].m_uLastDownEvent;
		}

		void SetLastDownEvent( uint32 uButtonIdx, uint32 uLastDownEvent )
		{
			GUI_ASSERT( uButtonIdx < _MOUSE_BUTTON_MAX_, "invalid button idx" );
			m_aButtonTrack[uButtonIdx].m_uLastDownEvent = uLastDownEvent;
		}

		CGUIWidget* GetTargetWidget( uint32 uButtonIdx )
		{
			GUI_ASSERT( uButtonIdx < _MOUSE_BUTTON_MAX_, "invalid button idx" );
			return m_aButtonTrack[uButtonIdx].m_pTargetWidget;
		}

		void SetTargetWidget( uint32 uButtonIdx, CGUIWidget* pTargetWidget )
		{
			GUI_ASSERT( uButtonIdx < _MOUSE_BUTTON_MAX_, "invalid button idx" );
			if( m_aButtonTrack[uButtonIdx].m_pTargetWidget == pTargetWidget )
			{
				return;
			}
			if( m_aButtonTrack[uButtonIdx].m_pTargetWidget )
			{
				m_aButtonTrack[uButtonIdx].m_pTargetWidget->GetOnWidgetDestroyedSignal().disconnect( this );
			}
			m_aButtonTrack[uButtonIdx].m_pTargetWidget = pTargetWidget;
			if( m_aButtonTrack[uButtonIdx].m_pTargetWidget )
			{
				m_aButtonTrack[uButtonIdx].m_pTargetWidget->GetOnWidgetDestroyedSignal().connect( this, &CMouseTracker::OnWidgetDestroyed );
			}
		}

	private:
		struct 
		{
			real m_fTimer; //!< Timer used to track clicks for this button.
			uint32 m_nClickCount; //!< count of clicks made so far.
			CGUIWidget* m_pTargetWidget; //!< target window for any events generated.
			uint32 m_uLastDownEvent; //!< last event generated by mouse down
		}
		m_aButtonTrack[_MOUSE_BUTTON_MAX_];
		CGUIWidget* m_pWidgetUnderMouse;	//!< the widget that under mouse
	};



	/**
	* @brief used for drag
	*/
	class CDragTracker : public sigslot::has_slots<>
	{
	public:
		/// constructor
		CDragTracker()
			:m_pDragItem(NULL)
		{
		}

		/// reset the tracker
		void Reset()
		{
			SetDragItem( NULL );
		}

		void OnWidgetDestroyed( CGUIWidget* pWidget )
		{
			if( m_pDragItem == pWidget )
			{
				m_pDragItem = NULL;
			}
		}

		void SetDragItem( CGUIWidget* pDragItem )
		{
			if( m_pDragItem == pDragItem )
			{
				return;
			}
			if( m_pDragItem )
			{
				m_pDragItem->GetOnWidgetDestroyedSignal().disconnect( this );
			}
			m_pDragItem = pDragItem;
			if( m_pDragItem )
			{
				m_pDragItem->GetOnWidgetDestroyedSignal().connect( this, &CDragTracker::OnWidgetDestroyed );
			}
		}

		CGUIWidget* GetDragItem()
		{
			return m_pDragItem;
		}

	public:
		CGUIVector2 m_aDeltaPos; ///!< this value is used to calculate the widget's position.
		int32 m_nButton; ///!< button of mouse which used to drag widget

	private:
		CGUIWidget* m_pDragItem; ///!< the widget which is being dragged now.
	};
}


//============================================================================//
// function
//============================================================================// 
namespace guiex
{
	//------------------------------------------------------------------------------
	CGUIInputProcessor::CGUIInputProcessor()
		:m_pMouseTracker(new CMouseTracker)
		,m_pDragTracker(new CDragTracker)
		,m_fDbClickTimeout(GUI_DBCLICK_TIME)
	{
		GUI_ASSERT(m_pMouseTracker,"error");
		GUI_ASSERT(m_pDragTracker,"error");
	}
	//------------------------------------------------------------------------------
	CGUIInputProcessor::~CGUIInputProcessor()
	{
		delete m_pMouseTracker;
		delete m_pDragTracker;
		ClearAllMouseListener();
	}
	//------------------------------------------------------------------------------
	/** 
	* @brief reset the input processor
	*/
	void CGUIInputProcessor::Reset()
	{
		m_pMouseTracker->Reset();	
		m_pDragTracker->Reset();
	}
	//------------------------------------------------------------------------------
	/**
	* @brief process keyboard and generate relative event
	* @return whether this keyboard event has been processed
	*/
	bool CGUIInputProcessor::ProcessKeyboard(const IGUIInterfaceKeyboard::SKeyEvent& rKeyEvent)
	{
		IGUIInterfaceKeyboard* pKeyboard = CGUIInterfaceManager::Instance()->GetInterfaceKeyboard();
		pKeyboard->PreUpdate();

		//get key status
		CGUIWidget *pFocusWidget = GSystem->GetFocusWidget();

		uint32	nEventId = 0;
		switch(rKeyEvent.m_eKeyEvent)
		{
		case KEY_EVENT_DOWN:
			nEventId = eEVENT_KEY_DOWN;
			break;
		case KEY_EVENT_UP:
			nEventId = eEVENT_KEY_UP;
			break;
		case KEY_EVENT_PRESSED:
			nEventId = eEVENT_KEY_PRESSED;
			break;
		case KEY_EVENT_CLICKED:
			nEventId = eEVENT_KEY_CLICKED;
			break;
		default:
			GUI_FORCE_ASSERT("unknown keyboard id");
			break;
		}

		//event
		CGUIEventKeyboard aEvent;
		aEvent.SetEventId(nEventId);	
		aEvent.SetKeyCode( rKeyEvent.m_eKeyCode);
		aEvent.SetKeyboardInterface(pKeyboard);
		if( pFocusWidget )
		{
			//focus widget process this event at first
			aEvent.SetReceiver(pFocusWidget);
			GSystem->SendEvent(&aEvent);
		}

		if( !aEvent.IsConsumed())
		{
			//the focus widget doesn't process this event, check global
			//key register now
			GSystem->ProcessGlobalKeyEvent(&aEvent);
		}

		//update keyboard status
		pKeyboard->PostUpdate();

		return aEvent.IsConsumed();
	}
	//------------------------------------------------------------------------------
	void CGUIInputProcessor::AddMouseListener( CGUIMouseListener* pListener )
	{
		m_vecMouseListener.push_back( pListener );
	}
	//------------------------------------------------------------------------------
	void CGUIInputProcessor::ClearMouseListener(CGUIMouseListener* pListener )
	{
		for( std::vector<CGUIMouseListener*>::iterator itor = m_vecMouseListener.begin();
			itor != m_vecMouseListener.end();
			++itor )
		{
			if( *itor == pListener )
			{
				delete *itor;
				m_vecMouseListener.erase( itor );
				return;
			}
		}
		GUI_THROW( "CGUIInputProcessor::ClearMouseListener: invalid CGUIMouseListener pointer!");
	}
	//------------------------------------------------------------------------------
	void CGUIInputProcessor::ClearAllMouseListener( )
	{
		for( std::vector<CGUIMouseListener*>::iterator itor = m_vecMouseListener.begin();
			itor != m_vecMouseListener.end();
			++itor )
		{
			delete *itor;
		}
		m_vecMouseListener.clear();
	}
	//------------------------------------------------------------------------------
	/**
	* @brief process mouse and generate relative event
	* @return whether this mouse event has been processed
	*/
	bool CGUIInputProcessor::ProcessMouse(const IGUIInterfaceMouse::SMouseEvent& rMouseEvent)
	{
		IGUIInterfaceMouse* pMouse = CGUIInterfaceManager::Instance()->GetInterfaceMouse();
		pMouse->PreUpdate();

		bool bConsumed = false;

		switch(rMouseEvent.m_eMouseEvent)
		{
		case MOUSE_EVENT_MOVE:
			for( std::vector<CGUIMouseListener*>::iterator itor = m_vecMouseListener.begin();
				itor != m_vecMouseListener.end();
				++itor )
			{
				(*itor)->OnMouseMove( rMouseEvent );
			}
			bConsumed = OnMouseMove(rMouseEvent);
			break;
		case MOUSE_EVENT_DOWN:
			for( std::vector<CGUIMouseListener*>::iterator itor = m_vecMouseListener.begin();
				itor != m_vecMouseListener.end();
				++itor )
			{
				(*itor)->OnMouseButtonDown( rMouseEvent );
			}
			bConsumed = OnMouseButtonDown(rMouseEvent);
			break;
		case MOUSE_EVENT_UP:
			for( std::vector<CGUIMouseListener*>::iterator itor = m_vecMouseListener.begin();
				itor != m_vecMouseListener.end();
				++itor )
			{
				(*itor)->OnMouseButtonUp( rMouseEvent );
			}
			bConsumed = OnMouseButtonUp(rMouseEvent);
			break;
		case MOUSE_EVENT_WHEEL:
			bConsumed = OnMouseWheelChange(rMouseEvent);
			break;
		default:
			GUI_FORCE_ASSERT("unknown mouse event");
			break;
		}

		//update mouse status
		pMouse->PostUpdate();

		return bConsumed;
	}
	//------------------------------------------------------------------------------
	bool CGUIInputProcessor::OnMouseButtonDown(const IGUIInterfaceMouse::SMouseEvent& rMouseEvent)
	{
		bool bConsumed = false;

		CGUIWidget* pTargetWidget = GSystem->GetWidgetUnderPoint(rMouseEvent.m_aMousePos);

		if( !m_pMouseTracker->GetTargetWidget(rMouseEvent.m_eButton) ||
			pTargetWidget != m_pMouseTracker->GetTargetWidget(rMouseEvent.m_eButton) ||
			GSystem->GetSystemTime() - m_pMouseTracker->GetTimer(rMouseEvent.m_eButton) > static_cast<int32>(m_fDbClickTimeout))
		{
			//reset mouse tracker
			m_pMouseTracker->SetTargetWidget(rMouseEvent.m_eButton, pTargetWidget );
			m_pMouseTracker->SetClickCount(rMouseEvent.m_eButton, 1);
		}
		else
		{
			//add click count
			m_pMouseTracker->SetClickCount( rMouseEvent.m_eButton, m_pMouseTracker->GetClickCount(rMouseEvent.m_eButton ));
		}
		//re-initialize timer
		m_pMouseTracker->SetTimer(rMouseEvent.m_eButton, GSystem->GetSystemTime());

		if( pTargetWidget )
		{
			//set focus
			if( GSystem->GetFocusWidget() != pTargetWidget)
			{
				if( pTargetWidget->IsFocusable())
				{
					pTargetWidget->SetFocus(true);
				}
			}

			//set active
			if( pTargetWidget->IsDerivedActivable())
			{
				CGUIEventNotification aEvent;
				aEvent.SetEventId(eEVENT_ACTIVE);
				aEvent.SetReceiver(pTargetWidget);
				GSystem->SendEvent(&aEvent);
			}

			//mouse down, mouse double click and multi click event
			CGUIEventMouse aEventMouse;
			aEventMouse.SetButton( rMouseEvent.m_eButton );
			aEventMouse.SetReceiver( pTargetWidget );
			aEventMouse.SetGlobalPosition(rMouseEvent.m_aMousePos);
			aEventMouse.SetKeyboardInterface(CGUIInterfaceManager::Instance()->GetInterfaceKeyboard());


			switch( m_pMouseTracker->GetClickCount( rMouseEvent.m_eButton ))
			{
			case 1:
				aEventMouse.SetEventId(eEVENT_MOUSE_DOWN);
				break;

			case 2:
				if( pTargetWidget->IsGenerateDBClickEvent())
				{
					aEventMouse.SetEventId(eEVENT_MOUSE_DBCLICK);
				}
				else
				{
					aEventMouse.SetEventId(eEVENT_MOUSE_DOWN);
				}
				break;

			default:
				if( pTargetWidget->IsGenerateMultiClickEvent())
				{
					aEventMouse.SetEventId(eEVENT_MOUSE_MULTI_CLICK);
					aEventMouse.SetMultiClickCount(m_pMouseTracker->GetClickCount( rMouseEvent.m_eButton ));
				}
				else
				{
					aEventMouse.SetEventId(eEVENT_MOUSE_DOWN);
				}
				break;
			}

			//for drag event
			if( pTargetWidget->IsMovable() &&
				aEventMouse.GetEventId() == eEVENT_MOUSE_DOWN &&
				rMouseEvent.m_eButton == MOUSE_LEFT )
			{
				//send drag begin event
				CGUIEventDrag aEventDrag;
				aEventDrag.SetEventId(eEVENT_DRAG_BEGIN );
				aEventDrag.SetReceiver( pTargetWidget );
				aEventDrag.SetButton( rMouseEvent.m_eButton );
				aEventDrag.SetWidgetLocalPos(pTargetWidget->GetPixelPosition());
				aEventDrag.SetMouseGlobalPos(rMouseEvent.m_aMousePos);
				GSystem->SendEvent(&aEventDrag);
				bConsumed |= aEventDrag.IsConsumed();

				if( !aEventDrag.IsExpired())
				{
					//set drag tracker
					BeginDrag( pTargetWidget, pTargetWidget->GetPixelPosition()-rMouseEvent.m_aMousePos, rMouseEvent.m_eButton);
				}
			}
			m_pMouseTracker->SetLastDownEvent(rMouseEvent.m_eButton, aEventMouse.GetEventId());

			//mouse down event
			GSystem->SendEvent(&aEventMouse);
			bConsumed |= aEventMouse.IsConsumed();
		}
		else
		{
			if( GSystem->GetFocusWidget() )
			{
				GSystem->GetFocusWidget()->SetFocus(false);
			}
		}

		return bConsumed;
	}
	//------------------------------------------------------------------------------
	void CGUIInputProcessor::BeginDrag(CGUIWidget* pWidget, const CGUIVector2& rDeltaPos, uint32 nButton)
	{
		m_pDragTracker->SetDragItem( pWidget );
		m_pDragTracker->m_aDeltaPos = rDeltaPos;
		m_pDragTracker->m_nButton = nButton;
	}
	//------------------------------------------------------------------------------
	void CGUIInputProcessor::EndDrag()
	{
		//clear drag tracker
		m_pDragTracker->SetDragItem( NULL );
	}
	//------------------------------------------------------------------------------
	bool CGUIInputProcessor::OnMouseButtonUp(const IGUIInterfaceMouse::SMouseEvent& rMouseEvent)
	{
		bool bConsumed = false;

		//for mouse up event
		CGUIWidget* pTargetWidget = GSystem->GetWidgetUnderPoint(rMouseEvent.m_aMousePos);

		if( pTargetWidget &&
			pTargetWidget == m_pMouseTracker->GetTargetWidget(rMouseEvent.m_eButton) )
		{
			if( m_pMouseTracker->GetLastDownEvent(rMouseEvent.m_eButton) == eEVENT_MOUSE_DOWN &&
				pTargetWidget->IsGenerateClickEvent())
			{
				//click event
				CGUIEventMouse aEventMouse;
				aEventMouse.SetEventId(eEVENT_MOUSE_CLICK);
				aEventMouse.SetButton( rMouseEvent.m_eButton );
				aEventMouse.SetGlobalPosition(rMouseEvent.m_aMousePos);
				aEventMouse.SetReceiver(pTargetWidget);
				aEventMouse.SetKeyboardInterface(CGUIInterfaceManager::Instance()->GetInterfaceKeyboard());
				GSystem->SendEvent(&aEventMouse);

				bConsumed |= aEventMouse.IsConsumed();
			}

			//mouse up event for this target
			CGUIEventMouse  aEventMouse;
			aEventMouse.SetEventId(eEVENT_MOUSE_UP);
			aEventMouse.SetButton( rMouseEvent.m_eButton );
			aEventMouse.SetReceiver(pTargetWidget);
			aEventMouse.SetGlobalPosition(rMouseEvent.m_aMousePos);
			aEventMouse.SetKeyboardInterface(CGUIInterfaceManager::Instance()->GetInterfaceKeyboard());
			GSystem->SendEvent(&aEventMouse);

			bConsumed |= aEventMouse.IsConsumed();
		}
		else
		{
			if( m_pMouseTracker->GetTargetWidget(rMouseEvent.m_eButton) )
			{
				//mouse up event for old target
				CGUIEventMouse aEventMouse;
				aEventMouse.SetEventId(eEVENT_MOUSE_UP);
				aEventMouse.SetButton( rMouseEvent.m_eButton );
				aEventMouse.SetReceiver(m_pMouseTracker->GetTargetWidget(rMouseEvent.m_eButton));
				aEventMouse.SetGlobalPosition(rMouseEvent.m_aMousePos);
				aEventMouse.SetKeyboardInterface(CGUIInterfaceManager::Instance()->GetInterfaceKeyboard());
				GSystem->SendEvent(&aEventMouse);

				bConsumed |= aEventMouse.IsConsumed();
			}
			if( pTargetWidget )
			{
				//mouse up event for current target
				CGUIEventMouse aEventMouse;
				aEventMouse.SetEventId(eEVENT_MOUSE_UP);
				aEventMouse.SetButton( rMouseEvent.m_eButton );
				aEventMouse.SetReceiver(pTargetWidget);
				aEventMouse.SetGlobalPosition(rMouseEvent.m_aMousePos);
				aEventMouse.SetKeyboardInterface(CGUIInterfaceManager::Instance()->GetInterfaceKeyboard());
				GSystem->SendEvent(&aEventMouse);

				bConsumed |= aEventMouse.IsConsumed();
			}
		}

		// for drag event
		if(	rMouseEvent.m_eButton == m_pDragTracker->m_nButton  &&
			m_pDragTracker->GetDragItem())
		{
			// send drag end event
			CGUIEventDrag aEventDrag;
			aEventDrag.SetEventId(eEVENT_DRAG_END );
			aEventDrag.SetReceiver( m_pDragTracker->GetDragItem() );
			aEventDrag.SetWidgetLocalPos(m_pDragTracker->m_aDeltaPos + rMouseEvent.m_aMousePos);
			aEventDrag.SetMouseGlobalPos(rMouseEvent.m_aMousePos);
			GSystem->SendEvent(&aEventDrag);
			bConsumed |= aEventDrag.IsConsumed();

			EndDrag();
		}

		return bConsumed;
	}
	//------------------------------------------------------------------------------
	bool	CGUIInputProcessor::OnMouseWheelChange(const IGUIInterfaceMouse::SMouseEvent& rMouseEvent)
	{
		bool bConsumed = false;

		CGUIWidget* pTargetWidget = GSystem->GetWidgetUnderPoint(rMouseEvent.m_aMousePos);

		if( pTargetWidget )
		{
			//mouse up event for current target
			CGUIEventMouse aEventMouse;
			aEventMouse.SetEventId(eEVENT_MOUSE_WHEEL);
			aEventMouse.SetReceiver(pTargetWidget);
			aEventMouse.SetGlobalPosition(rMouseEvent.m_aMousePos);
			aEventMouse.SetWheelChange(rMouseEvent.m_fWheelChange);
			aEventMouse.SetKeyboardInterface(CGUIInterfaceManager::Instance()->GetInterfaceKeyboard());
			GSystem->SendEvent(&aEventMouse);

			bConsumed |= aEventMouse.IsConsumed();
		}

		return bConsumed;
	}
	//------------------------------------------------------------------------------
	bool	CGUIInputProcessor::OnMouseMove(const IGUIInterfaceMouse::SMouseEvent& rMouseEvent)
	{
		bool bConsumed = false;

		//update mouse position
		CGUIMouseCursor::Instance()->SetPosition(rMouseEvent.m_aMousePos);

		// for drag event
		if(m_pDragTracker->GetDragItem())
		{
			// send drag end event
			CGUIEventDrag aEventDrag;
			aEventDrag.SetEventId(eEVENT_DRAG_PROCESS );
			aEventDrag.SetReceiver( m_pDragTracker->GetDragItem() );
			aEventDrag.SetWidgetLocalPos( m_pDragTracker->m_aDeltaPos + rMouseEvent.m_aMousePos);
			aEventDrag.SetMouseGlobalPos(rMouseEvent.m_aMousePos);
			GSystem->SendEvent(&aEventDrag);

			bConsumed |= aEventDrag.IsConsumed();
		}
		else
		{
			CGUIWidget* pTargetWidget = GSystem->GetWidgetUnderPoint(rMouseEvent.m_aMousePos);


			//mouse leave and mouse enter event
			if( m_pMouseTracker->GetWidgetUnderMouse() != pTargetWidget )
			{
				//mouse leave
				if( m_pMouseTracker->GetWidgetUnderMouse() )
				{
					{
						//mouse move
						CGUIEventMouse aEventMouse;
						aEventMouse.SetEventId(eEVENT_MOUSE_MOVE);
						aEventMouse.SetReceiver(m_pMouseTracker->GetWidgetUnderMouse());
						aEventMouse.SetGlobalPosition(rMouseEvent.m_aMousePos);
						aEventMouse.SetKeyboardInterface(CGUIInterfaceManager::Instance()->GetInterfaceKeyboard());
						GSystem->SendEvent(&aEventMouse);
					}

					{
						//mouse leave event for curent target
						CGUIEventMouse aEventMouse;
						aEventMouse.SetEventId(eEVENT_MOUSE_LEAVE);
						aEventMouse.SetReceiver(m_pMouseTracker->GetWidgetUnderMouse());
						aEventMouse.SetGlobalPosition(rMouseEvent.m_aMousePos);
						aEventMouse.SetKeyboardInterface(CGUIInterfaceManager::Instance()->GetInterfaceKeyboard());
						GSystem->SendEvent(&aEventMouse);
					}
				}

				if( pTargetWidget )
				{
					//mouse enter event
					CGUIEventMouse aEventMouse;
					aEventMouse.SetEventId(eEVENT_MOUSE_ENTER);
					aEventMouse.SetReceiver(pTargetWidget);
					aEventMouse.SetGlobalPosition(rMouseEvent.m_aMousePos);
					aEventMouse.SetKeyboardInterface(CGUIInterfaceManager::Instance()->GetInterfaceKeyboard());
					GSystem->SendEvent(&aEventMouse);
				}

				m_pMouseTracker->SetWidgetUnderMouse( pTargetWidget );
			}
			else if( m_pMouseTracker->GetWidgetUnderMouse() )
			{
				//mouse move event for current target
				CGUIEventMouse aEventMouse;
				aEventMouse.SetEventId(eEVENT_MOUSE_MOVE);
				aEventMouse.SetReceiver(m_pMouseTracker->GetWidgetUnderMouse());
				aEventMouse.SetGlobalPosition(rMouseEvent.m_aMousePos);
				aEventMouse.SetKeyboardInterface(CGUIInterfaceManager::Instance()->GetInterfaceKeyboard());
				GSystem->SendEvent(&aEventMouse);
			}
		}
		return bConsumed;
	}

}	//namespace
